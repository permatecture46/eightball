<html>
<head>
</head>
<body>
  <div id="container">
    <svg xmlns="http://www.w3.org/2000/svg">
      <rect id="screen"/>

      <rect id="guardrails"/>

      <rect id="table"/>

      <rect id="powerselector"/>
      <rect id="powerdisplay"/>
      <rect id="stick"/>
      <rect id="powerselectorbottom"/>
      <rect id="block"/>
      <rect id="powerselectorcover"/>

      <rect class="cornerlane" id="topleftlane" transform="rotate(135)"/>
      <rect class="cornerlane" id="toprightlane" transform="rotate(45)"/>
      <rect class="cornerlane" id="bottomleftlane" transform="rotate(45)"/>
      <rect class="cornerlane" id="bottomrightlane" transform="rotate(135)"/>

      <rect class="sidelane" id="bottomleftsidelane" transform="rotate(65)"/>
      <rect class="sidelane" id="bottomrightsidelane" transform="rotate(115)"/>
      <rect class="sidelane" id="topleftsidelane" transform="rotate(25)"/>
      <rect class="sidelane" id="toprightsidelane" transform="rotate(155)"/>

      <circle class="sidehole" id="topsidehole"/>
      <circle class="sidehole" id="bottomsidehole"/>

      <circle class="cornerhole" id="toplefthole"/>
      <circle class="cornerhole" id="toprighthole"/>
      <circle class="cornerhole" id="bottomlefthole"/>
      <circle class="cornerhole" id="bottomrighthole"/>

    </svg>
  </div>
</body>
<script>

  var BALL_RADIUS_PERCENTAGE = .015; // .0205; // this value makes it so it becomes the actual American standard of ~.026
  var ACTUAL_BALL_RADIUS_PERCENTAGE = BALL_RADIUS_PERCENTAGE + .265 * BALL_RADIUS_PERCENTAGE; // for some reason this is how it renders...
  var BALL_RADIUS = BALL_RADIUS_PERCENTAGE * 100 + "%";
  var TABLE_WIDTH, TABLE_HEIGHT, TABLE_X, TABLE_Y, BALL_RADIUS_VALUE;
  var TIME_BETWEEN_INCREMENTS = 1;
  var MAX_DISTANCE_MOVED = 50;
  var TEST_BALL_NUM = 8;

  var CORNER_MIN_X, CORNER_MAX_X, CORNER_MIN_Y, CORNER_MAX_Y;
  var SIDE_MIN, SIDE_MAX;
  var SCREEN_X, SCREEN_Y, SCREEN_HEIGHT;
  var CORNER_LANE_SLOPE = 1, CORNER_LANE_SLOPE_2 = -1;
  var SIDE_LANE_SLOPE = 2.145;

  var BOTTOM_LEFT_HOLE_X, BOTTOM_LEFT_HOLE_Y, BOTTOM_RIGHT_HOLE_X, BOTTOM_RIGHT_HOLE_Y;
  var TOP_LEFT_HOLE_X, TOP_LEFT_HOLE_Y, TOP_RIGHT_HOLE_X, TOP_RIGHT_HOLE_Y;
  var BOTTOM_SIDE_HOLE_X, BOTTOM_SIDE_HOLE_Y;
  var TOP_SIDE_HOLE_X, TOP_SIDE_HOLE_Y;
  var SIDE_HOLE_RADIUS, CORNER_HOLE_RADIUS;

  var DISTANCE_MOVED_DECREASE_FACTOR = .01, DECREASE_UPON_REFLECTION_FACTOR = .5;

  var HOLE_RANGE = 100;

  var ballsOnTable = [];
  var gameStarted = false;

  var selectingPower = false;
  var stickSet = false;
  var ballsMoving = false;
  var mouseDownStartingY, STICK_HEIGHT_PERCENTAGE = 47, STICK_Y_PERCENTAGE = 32;
  var predictedLocationData;

  var MARGIN_TOP = 50;

  var STICK_TO_CUE_DISTANCE = 15, STICK_END_TO_CUE_DISTANCE = 160;

  window.addEventListener('load', function(event) {
    setTableSizeVariables();
    ballsOnTable = placeRandomBalls();
    ballsOnTable.push(placeRandomBall('white'));
    //ballsOnTable = placeNonrandomBalls();
    setPredictedCueLocationListener();
    setClickListener();
    setMouseDownListener();
    setMouseMoveListener();
    setMouseUpListener();
    setDefaultStick();
  });

  function setDefaultStick() {
    var cueBall = document.getElementById('cueball');
    if (cueBall) { 
      var cursorLocation = {};
      if (cueBall.x < TABLE_X + TABLE_WIDTH / 2) {
        cursorLocation.x = TABLE_X + TABLE_WIDTH * .75;
        cursorLocation.y = cueBall.y - TABLE_Y;
      }
      else {
        cursorLocation.x = TABLE_X + TABLE_WIDTH * .25;
        cursorLocation.y = cueBall.y - TABLE_Y;
      }
      placePredictorGraphics(cueBall, cursorLocation.x, cursorLocation.y, cueBall.x, cueBall.y);
    }
  }

  function setPredictedCueLocationListener() {
    document.addEventListener('mousemove', function(event) {
      var cueBall = document.getElementById('cueball');
      if (cueBall) {
        var cursorLocation = getElementTableLocation(event.clientX, event.clientY);
        if (cursorOnTable(cursorLocation.x, cursorLocation.y)) {
          if (!stickSet && !ballsMoving) {
            placePredictorGraphics(cueBall, cursorLocation.x, cursorLocation.y, cueBall.x, cueBall.y);
          }
        }
        else {
          stickSet = false; // unglue stick when mouse returns to table
        }
      }
    });
  }

  function placePredictorGraphics(cueBall, cursorX, cursorY, cueBallX, cueBallY) {
    predictedLocationData = getPredictedCueLocationData(cursorX, cursorY, cueBallX, cueBallY);
    placePredictorBall(predictedLocationData.x + 'px', predictedLocationData.y + 'px');
    placePredictedPath(predictedLocationData.x, predictedLocationData.y, cueBallX, cueBallY);
    placeCueStick(predictedLocationData.x, predictedLocationData.y, cueBallX, cueBallY);
    if (predictedLocationData.ball) {
      setMovementData(cueBallX, cueBallY, cursorX + TABLE_X, cursorY + TABLE_Y, cueBall);
      var predictorBall = document.getElementById('predictorball');
      setMovementData(cueBallX, cueBallY, cursorX + TABLE_X, cursorY + TABLE_Y, predictorBall);
      placeReflectedPath(predictorBall, predictedLocationData.ball);
      placeBallStruckPath(predictorBall, predictedLocationData.ball);
    }
    else {
      clearPaths();
      setMovementData(cueBallX, cueBallY, cursorX + TABLE_X, cursorY + TABLE_Y, cueBall);
    }
  }

  function placeBallStruckPath(cueBall, ballStruck) {
    ballStruck.slope = (ballStruck.y - cueBall.y) / (ballStruck.x - cueBall.x);
    var newBallStruckData = calculateBallDataAfterBeingStruck(cueBall, ballStruck);
    var X1 = ballStruck.x;
    var Y1 = ballStruck.y;
    var X2change = (50 / Math.sqrt(1 + Math.pow(ballStruck.slope, 2))) * (newBallStruckData.direction == 'left' ? -1 : 1);
    var X2 = X1 + X2change;
    var Y2 = Y1 + ballStruck.slope * X2change;
    var bspath = document.getElementById('ballstruckpath');
    if (!bspath) {
      appendSVG('line', function(element){
        bspath = element;
        element.id = 'ballstruckpath';
        element.style.stroke = 'white';
        element.style.strokeWidth = '2px';
      });
    }
    bspath.setAttribute('x1', X1);
    bspath.setAttribute('y1', Y1);
    bspath.setAttribute('x2', X2);
    bspath.setAttribute('y2', Y2);
  }

  function clearPaths() {
    clearElements('reflectionpath', 'ballstruckpath');
  }

  function placeReflectedPath(cueBall, ballIntersecting) {
    var newBallData = calculateBallDataAfterStriking(cueBall, ballIntersecting);
    var X1 = cueBall.x;
    var Y1 = cueBall.y;
    var X2change = (50 / Math.sqrt(1 + Math.pow(newBallData.slope, 2))) * (newBallData.direction == 'left' ? -1 : 1);
    var X2 = X1 + X2change;
    var Y2 = Y1 + newBallData.slope * X2change;
    var rpath = document.getElementById('reflectionpath');
    if (!rpath) {
      appendSVG('line', function(element){
        rpath = element;
        element.id = 'reflectionpath';
        element.style.stroke = 'white';
        element.style.strokeWidth = '2px';
      });
    }
    rpath.setAttribute('x1', X1);
    rpath.setAttribute('y1', Y1);
    rpath.setAttribute('x2', X2);
    rpath.setAttribute('y2', Y2);
  }

  function placeCueStick(x1, y1, x2, y2){
    var slope = (y2 - y1) / (x2 - x1);
    var X1change = (STICK_TO_CUE_DISTANCE / Math.sqrt(1 + Math.pow(slope, 2))) * (x1 - x2 > 0 ? -1 : 1);
    var X1 = x2 + X1change;
    var Y1 = y2 + slope * X1change;
    var X2change = STICK_END_TO_CUE_DISTANCE / Math.sqrt(1 + Math.pow(slope, 2)) * (x1 - x2 > 0 ? -1 : 1);
    var X2 = x2 + X2change;
    var Y2 = y2 + slope * X2change;
    var stick = document.getElementById('stick2');
    if (!stick) {
      appendSVG('line', function(element) {
        stick = element;
        element.id = 'stick2';
        element.style.stroke = 'yellow';
        element.style.strokeWidth = '4px';
      });
    }
    stick.setAttribute('x1', X1);
    stick.setAttribute('y1', Y1);
    stick.setAttribute('x2', X2);
    stick.setAttribute('y2', Y2);
  }

  function setClickListener() {
    document.addEventListener('click', function(event) {
      var cursorLocationOnTable = getElementTableLocation(adjustedPositionX(event.clientX), adjustedPositionY(event.clientY));
      if (cursorLocationOnTable.x > TABLE_X && cursorLocationOnTable.y > TABLE_Y) {
        stickSet = !stickSet;
      }
    });
  }

  function setMouseDownListener() {
    document.addEventListener('mousedown', function(event) {
      if (event.target.id == 'stick') {
        selectingPower = true;
        mouseDownStartingY = event.offsetY;
      }
    });
  }

  function setMouseMoveListener() {
    document.addEventListener('mousemove', function(event) {
      if (selectingPower) {
        var stickOffsetY = event.offsetY - mouseDownStartingY;
        if (stickOffsetY > 0) {
          var stickHeightNum = STICK_HEIGHT_PERCENTAGE * SCREEN_HEIGHT * .01;
          if (stickOffsetY > stickHeightNum) {
            stickOffsetY = stickHeightNum;
          }
          var stick = document.getElementById('stick');
          stick.style.y = STICK_Y_PERCENTAGE + stickOffsetY / stickHeightNum * STICK_HEIGHT_PERCENTAGE + '%';
        }
      }
    });
  }

  function setMouseUpListener() {
    document.addEventListener('mouseup', function(event) {
      if (selectingPower) {
        selectingPower = false;
        var stick = document.getElementById('stick');
        var offsetY = stick.getBoundingClientRect().y;
        var originalOffsetY = STICK_Y_PERCENTAGE * .01 * SCREEN_HEIGHT + MARGIN_TOP;
        var y = offsetY - originalOffsetY;
        var stickHeight = STICK_HEIGHT_PERCENTAGE * .01 * SCREEN_HEIGHT;
        var powerPercentage = y / stickHeight;
        var cueBall = document.getElementById('cueball');
        cueBall.distanceMovedPerIncrement = powerPercentage * MAX_DISTANCE_MOVED;
        cueBall.isMoving = true;
        ballsMoving = true;
        clearPredictorGraphics();
        fadeOutPowerSelector();
        if (!gameStarted) {
          gameStarted = true;
          incrementLocationsOfBalls();
        }
      }
    });
  }
  
  function clearPredictorGraphics() {
    clearElements('stick2', 'reflectionpath', 'ballstruckpath', 'cuepath', 'predictorball');
  }

  function clearElements(){
    for (var i = 0; i < arguments.length; i++) {
      var id = arguments[i];
      var element = document.getElementById(id);
      if (element) {
        element.parentNode.removeChild(element);
      }
    }
  }

  function setMovementData(X1, Y1, X2, Y2, ball) {
    ball.slope = (Y2 - Y1) / (X2 - X1);
    ball.direction = X2 < X1 ? 'left' : 'right';
    ball.directionUpDown = Y2 > Y1 ? 'top' : 'bottom';
  }

  function placePredictedPath(x1, y1, x2, y2) {
    var cuePath = document.getElementById('cuepath');
    if (!cuePath) {
      appendSVG('line', function(element) {
        cuePath = element;
        element.id = 'cuepath';
        element.style.stroke = 'white';
        element.style.strokeWidth = '2px';
      });
    }
    cuePath.setAttribute('x1', x1);
    cuePath.setAttribute('y1', y1);
    cuePath.setAttribute('x2', x2);
    cuePath.setAttribute('y2', y2);
  }

  function incrementLocationsOfBalls() {
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ball = ballsOnTable[i];
      var ballStruck;
      if (ball.isMoving && !ball.hasBeenIncremented) {
        var newLocation = calculateNewLocation(ball);
        setNewLocation(ball, newLocation);
        ballStruck = ballStrikingOtherBall(ball);
        if (!!ballStruck && !ball.ballJustStruck) {
          adjustBallPosition(ball);
          var newBallData = calculateBallDataAfterStriking(ball, ballStruck);
          setNewBallData(ball, newBallData);
          ball.ballJustStruck = true;
          ballStruck.ballJustStruck = true;
          if (!ballStruck.isMoving) { // redo slopes
            ballStruck.isMoving = true;
            ballStruck.slope = newBallData.slopeBetweenBalls;
            var powerKeptByCue = getPowerKeptByCue(ball.slope, ballStruck.slope);
	    var newBallStruckData = calculateBallDataAfterBeingStruck(ball, ballStruck, powerKeptByCue);
            setNewBallStruckData(ballStruck, newBallStruckData);
            ballMovementDecrease(ball, 1 - powerKeptByCue);
          }
          else {
            var newBallData = calculateBallDataAfterStriking(ballStruck, ball);
            setNewBallData(ballStruck, newBallData);
            ballMovementDecrease(ballStruck, DECREASE_UPON_REFLECTION_FACTOR);
            ballMovementDecrease(ball, DECREASE_UPON_REFLECTION_FACTOR);
          }
          ballStruck.hasBeenIncremented = true;
        }
        else {
          predictedLocationData = null;
          ball.ballJustStruck = false;
          if (ballStruck) ballStruck.ballJustStruck = false;
          var ballReflecting = ballReflectingAgainstTable(ball);
          if (!!ballReflecting) { // implicit else if
            var newBallData = calculateBallDataAfterReflection(ballReflecting, ball.slope, ball.direction, ball.directionUpDown);
            setNewBallData(ball, newBallData);
            ballMovementDecrease(ball, DECREASE_UPON_REFLECTION_FACTOR);
          }
          else if (isBallInLane(ball)) {
            var closestHole = findClosestHole(ball);
            if (closestHole.distance && closestHole.distance < closestHole.radius) {
              removeBallFromWorkingSet(ball);
              ball.parentNode.removeChild(ball);
            }
            else if (!ball.reflecting) {
              var reflectingRail = isBallAgainstRail(ball, closestHole.name);
              if (!!reflectingRail) {
                var newBallData = calculateBallDataAfterLaneReflection(ball, closestHole.name, reflectingRail);
                setNewBallData(ball, newBallData);
                ball.reflecting = true;
                ballMovementDecrease(ball, DECREASE_UPON_REFLECTION_FACTOR);
              }
              else { 
                ball.reflecting = false;
              }
            }
            else {
            }
          }
        }
      }
      ballMovementDecrease(ball, DISTANCE_MOVED_DECREASE_FACTOR); // so that it slows down slower before it stops completely:
    }
    clearIncrementationNote(ballsOnTable);
    setTimeout(function() {
      incrementLocationsOfBalls();
    }, TIME_BETWEEN_INCREMENTS);
  }

  function getPowerKeptByCue(slope1, slope2) {
    var angle = Math.atan((slope1 - slope2) / (1 + slope1 * slope2));
    var percentage = Math.abs(angle / (Math.PI / 2));
    return percentage;
  }

  function adjustBallPosition(ball) {
    if (predictedLocationData) {
      ball.x = predictedLocationData.x;
      ball.y = predictedLocationData.y;
      predictedLocationData = null;
    }
  }
  
  function ballMovementDecrease(ball, factor) {
    if (ball.distanceMovedPerIncrement) {
      ball.distanceMovedPerIncrement -= factor * ball.distanceMovedPerIncrement;
      if (ball.distanceMovedPerIncrement <= .001 && ball.distanceMovedPerIncrement) {
        ball.distanceMovedPerIncrement = 0;
        ball.isMoving = false;
        if (ballsDoneMoving()) {
          ballsMoving = false;
          resetPowerSelector();
          setDefaultStick();
        }
      }
    }
  }

  function resetPowerSelector() {
    fadeInPowerSelector();
    var stick = document.getElementById('stick');
    stick.style.y = STICK_Y_PERCENTAGE + '%';
  }

  function fadeOutPowerSelector() {
    var powerSelectorCover = document.getElementById('powerselectorcover');
    powerSelectorCover.style.x = '5%';
    updateOpacityUp(0, powerSelectorCover);
  }

  function updateOpacityUp(i, cover) {
    var percentage = i / 25;
    cover.style.opacity = percentage * 1;
    i++;
    if (i <= 25) setTimeout(function() { updateOpacityUp(i, cover) }, 1);
  }

  function updateOpacityDown(i, cover, finalize) {
    var percentage = i / 25;
    cover.style.opacity = 1 - percentage * 1;
    i++;
    if (i <= 25) setTimeout(function() { updateOpacityDown(i, cover, finalize) }, 1);
    else finalize();
  }

  function fadeInPowerSelector() {
    var powerSelectorCover = document.getElementById('powerselectorcover');
    updateOpacityDown(0, powerSelectorCover, function() {
      powerSelectorCover.style.x = '0%'
    });
  }

  function ballsDoneMoving() {
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ball = ballsOnTable[i];
      if (ball.isMoving) {
        return false;
      }
    }
    return true;
  }

  function calculateBallDataAfterLaneReflection(ball, lane, rail) {
    var result = {}
    if (lane == 'BOTTOM_LEFT') {
      if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 * CORNER_LANE_SLOPE);
        result.direction = 'left';
        if (result.slope > 0) {
          result.directionUpDown = 'bottom';
        }
        else {
          result.directionUpDown = 'top';
        }
      }
      else if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 * CORNER_LANE_SLOPE);
        result.directionUpDown = 'bottom';
        if (result.slope > 0) {
          result.direction = 'left';
        }
        else {
          result.direction = 'right';
        }
      }
    }
    if (lane == 'BOTTOM_RIGHT') {
      if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, CORNER_LANE_SLOPE);
        result.directionUpDown = 'bottom';
        if (result.slope > 0) {
          result.direction = 'left';
        }
        else {
          result.direction = 'right';
        }
      }
      else if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, CORNER_LANE_SLOPE);
        result.direction = 'right';
        if (result.slope > 0) {
          result.directionUpDown = 'bottom';
        }
        else {
          result.directionUpDown = 'top';
        }
      }
    }
    if (lane == 'TOP_RIGHT') {
      if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 * CORNER_LANE_SLOPE);
        result.directionUpDown = 'top';
        if (result.slope > 0) {
          result.direction = 'right';
        }
        else {
          result.direction = 'left';
        }
      }
      else if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 * CORNER_LANE_SLOPE);
        result.direction = 'right';
        if (result.slope > 0) {
          result.directionUpDown = 'top';
        }
        else {
          result.directionUpDown = 'bottom';
        }
      }
    }
    if (lane == 'TOP_LEFT') {
      if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, CORNER_LANE_SLOPE);
        result.direction = 'left';
        if (result.slope > 0) {
          result.directionUpDown = 'top';
        }
        else {
          result.directionUpDown = 'bottom';
        }
      }
      else if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, CORNER_LANE_SLOPE);
        result.directionUpDown = 'top';
        if (result.slope > 0) {
          result.direction = 'right';
        }
        else {
          result.direction = 'left';
        }
      }
    }
    if (lane == 'BOTTOM_SIDE') {
      if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 / (-1 * SIDE_LANE_SLOPE));
        result.direction = 'right';
        if (result.slope > 0) {
          result.directionUpDown = 'top';
        }
        else {
          result.directionUpDown = 'bottom';
        }
      }
      else if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 / SIDE_LANE_SLOPE);
        result.direction = 'left';
        if (result.slope > 0) {
          result.directionUpDown = 'bottom';
        }
        else {
          result.directionUpDown = 'top';
        }
      }
    }
    if (lane == 'TOP_SIDE') {
      if (rail == 'right') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 / (-1 * SIDE_LANE_SLOPE));
        result.direction = 'left';
        if (result.slope > 0) {
          result.directionUpDown = 'bottom';
        }
        else {
          result.directionUpDown = 'top';
        }
      }
      else if (rail == 'left') {
        result.slope = getSlopeReflectingAcrossSlope(ball.slope, -1 / SIDE_LANE_SLOPE);
        result.direction = 'right';
        if (result.slope > 0) {
          result.directionUpDown = 'top';
        }
        else {
          result.directionUpDown = 'bottom';
        }
      }
    }
    return result;
  }

  function isBallAgainstRail(ball, lane) {
    if (lane == 'BOTTOM_LEFT') {
      var distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE, CORNER_MIN_X, TABLE_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
      distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE, TABLE_X, CORNER_MIN_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
    }
    else if (lane == 'BOTTOM_RIGHT') {
      var distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE_2, CORNER_MAX_X, TABLE_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
      distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE_2, TABLE_X + TABLE_WIDTH, CORNER_MIN_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
    }
    else if (lane == 'TOP_RIGHT') {
      var distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE, CORNER_MAX_X, TABLE_Y + TABLE_HEIGHT);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
      distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE, TABLE_X + TABLE_WIDTH, CORNER_MAX_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
    }
    else if (lane == 'TOP_LEFT') {
      var distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE_2, CORNER_MIN_X, TABLE_Y + TABLE_HEIGHT);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
      distance = distanceFromLine(ball.x, ball.y, CORNER_LANE_SLOPE_2, TABLE_X, CORNER_MAX_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
    }
    else if (lane == 'BOTTOM_SIDE') {
      var distance = distanceFromLine(ball.x, ball.y, SIDE_LANE_SLOPE, SIDE_MAX, TABLE_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
      var distance = distanceFromLine(ball.x, ball.y, -1 * SIDE_LANE_SLOPE, SIDE_MIN, TABLE_Y);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
    }
    else if (lane == 'TOP_SIDE') {
      var distance = distanceFromLine(ball.x, ball.y, SIDE_LANE_SLOPE, SIDE_MAX, TABLE_Y + TABLE_HEIGHT);
      if (distance < BALL_RADIUS_VALUE) {
        return 'right';
      }
      var distance = distanceFromLine(ball.x, ball.y, -1 * SIDE_LANE_SLOPE, SIDE_MIN, TABLE_Y + TABLE_HEIGHT);
      if (distance < BALL_RADIUS_VALUE) {
        return 'left';
      }
    }
  }

  function distanceFromLine(ballX, ballY, laneSlope, laneX, laneY) {
    var yIntLane = laneY - laneSlope * laneX;
    var perpendicularSlope = -1 / laneSlope;
    var yIntPerpendicularLine = ballY - perpendicularSlope * ballX;
    var intersectionX = (yIntLane - yIntPerpendicularLine) / (perpendicularSlope - laneSlope);
    var intersectionY = intersectionX * laneSlope + yIntLane;
    var distance = getDistance(ballX, ballY, intersectionX, intersectionY);
    return distance;
  }

  function isBallInLane(ball) {
    if (ball.x < TABLE_X || ball.y < TABLE_Y || ball.x > TABLE_X + TABLE_WIDTH || ball.y > TABLE_Y + TABLE_HEIGHT) {
      return true;
    }
  }

  function findClosestHole(ball) {
    var distance = getDistance(BOTTOM_LEFT_X, BOTTOM_LEFT_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'BOTTOM_LEFT',
        distance: distance,
        radius: CORNER_HOLE_RADIUS,
      };
    }
    var distance = getDistance(BOTTOM_RIGHT_X, BOTTOM_RIGHT_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'BOTTOM_RIGHT',
        distance: distance,
        radius: CORNER_HOLE_RADIUS,
      };
    }
    var distance = getDistance(TOP_RIGHT_X, TOP_RIGHT_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'TOP_RIGHT',
        distance: distance,
        radius: CORNER_HOLE_RADIUS,
      };
    }
    var distance = getDistance(TOP_LEFT_X, TOP_LEFT_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'TOP_LEFT',
        distance: distance,
        radius: CORNER_HOLE_RADIUS,
      };
    }
    var distance = getDistance(BOTTOM_SIDE_X, BOTTOM_SIDE_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'BOTTOM_SIDE',
        distance: distance,
        radius: SIDE_HOLE_RADIUS,
      };
    }
    var distance = getDistance(TOP_SIDE_X, TOP_SIDE_Y, ball.x, ball.y);
    if (distance < HOLE_RANGE) {
      return {
        name: 'TOP_SIDE',
        distance: distance,
        radius: SIDE_HOLE_RADIUS,
      };
    }
    return {};
  }

  function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  }

  function removeBallFromWorkingSet(ball){
    var newSet = [];
    for (var i = 0; i < ballsOnTable.length; i++) {
      if (ballsOnTable[i] != ball) {
        newSet.push(ballsOnTable[i]);
      }
    }
    ballsOnTable = newSet;
  }

  function findCommonDirection(ball1, ball2) {
    if (ball1.direction == 'right' && ball2.direction == 'right') {
      return 'right';
    }
    else if (ball1.direction == 'left' && ball2.direction == 'left') {
      return 'left';
    }
  }

  function reverseDirection(direction) {
    if (direction == 'left') {
      return 'right';
    }
    else if (direction == 'right') {
      return 'left';
    }
    else if (direction == 'top') {
      return 'bottom';
    }
    else if (direction == 'bottom') {
      return 'top';
    }
  }

  function setNewLocation(ball, newLocation) {
    ball.style.cx = newLocation.x + 'px';
    ball.style.cy = newLocation.y + 'px';
    ball.x = newLocation.x;
    ball.y = newLocation.y;
  }

  function setNewBallData(ball, newBallData) {
    ball.slope = newBallData.slope;
    ball.direction = newBallData.direction;
    ball.directionUpDown = newBallData.directionUpDown;
  }

  function setNewBallStruckData(ballStruck, newBallStruckData) {
    ballStruck.direction = newBallStruckData.direction;
    ballStruck.directionUpDown = newBallStruckData.directionUpDown;
    ballStruck.distanceMovedPerIncrement = newBallStruckData.distanceMovedPerIncrement;
  }

  function calculateBallDataAfterBeingStruck(ball, ballStruck, powerKeptByCue) {
    var newTrajectory = {};
    if (ball.distanceMovedPerIncrement && powerKeptByCue) {
      newTrajectory.distanceMovedPerIncrement = ball.distanceMovedPerIncrement * (1 - powerKeptByCue);
    }
    if (ball.x > ballStruck.x) { 
      newTrajectory.direction = 'left';
    }
    else if (ball.x < ballStruck.x) {
      newTrajectory.direction = 'right';
    }
    if (ball.y > ballStruck.y) { 
      newTrajectory.directionUpDown = 'bottom';
    }
    else if (ball.y < ballStruck.y) {
      newTrajectory.directionUpDown = 'top';
    }
    return newTrajectory;
  }

  function clearIncrementationNote(balls) {
    for (var i = 0; i < balls.length; i++) {
      var ball = balls[i];
      ball.hasBeenIncremented = false;
    }
  }

  function ballStrikingOtherBall(ball) {
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ballToCheck = ballsOnTable[i];
      if (ball != ballToCheck) {
        var distanceBetweenBalls = getHypotenuseFromDifferences(ball.x - ballToCheck.x, ball.y - ballToCheck.y);
        if (distanceBetweenBalls < 2 * BALL_RADIUS_VALUE) {
          return ballToCheck;
        }
      }
    }
  }

  function calculateBallDataAfterStriking(ball, ballStruck) {
    var lineBetween = {};
    lineBetween.slope = (ball.y - ballStruck.y) / (ball.x - ballStruck.x);
    lineBetween.yIntercept = ball.y - lineBetween.slope * ball.x;
    var newTrajectory = {};
    newTrajectory.slopeBetweenBalls = lineBetween.slope;
    var newSlope = getSlopeReflectingAcrossSlope(ball.slope, lineBetween.slope);
    newTrajectory.slope = newSlope;
    var oldSlope = ball.slope;
    var quadrant = getObjectQuadrant(ballStruck.x, ballStruck.y, ball.x, ball.y);
    if (newSlope > 0) {
      if ((oldSlope > 0 && ball.direction == 'left' && quadrant == 1) || 
         (oldSlope < 0 && ball.direction == 'right' && (quadrant == 2 || quadrant == 1) && Math.abs(lineBetween.slope) > oldSlope) ||
         (oldSlope < 0 && ball.directionUpDown == 'top' && (quadrant == 4 || quadrant == 1) && lineBetween.slope > oldSlope)) 
      {
        newTrajectory.direction = 'right';
        newTrajectory.directionUpDown = 'top';
      }
      else if ((oldSlope > 0 && ball.direction == 'right' && quadrant == 3) || 
         (oldSlope < 0 && ball.direction == 'left' && (quadrant == 3 || quadrant == 4) && Math.abs(lineBetween.slope) > oldSlope) ||
         (oldSlope < 0 && ball.directionUpDown == 'bottom' && (quadrant == 3 || quadrant == 2) && lineBetween.slope > oldSlope))
      {
        newTrajectory.direction = 'left';
        newTrajectory.directionUpDown = 'bottom';
      }
      else {
        newTrajectory.direction = ball.direction;
        newTrajectory.directionUpDown = ball.directionUpDown;
      }
    }
    else if (newSlope < 0) {
      if ((oldSlope < 0 && ball.direction == 'right' && quadrant == 2) || 
         (oldSlope > 0 && ball.direction == 'left' && (quadrant == 2 || quadrant == 1) && (lineBetween.slope > oldSlope || lineBetween.slope < 0)) ||
         (oldSlope > 0 && ball.directionUpDown == 'top' && (quadrant == 2 || quadrant == 3) && lineBetween.slope < oldSlope))
      {
        newTrajectory.direction = 'left';
        newTrajectory.directionUpDown = 'top';
      }
      else if ((oldSlope < 0 && ball.direction == 'left' && quadrant == 4) || 
         (oldSlope > 0 && ball.direction == 'right' && (quadrant == 3 || quadrant == 4) && (lineBetween.slope > oldSlope || lineBetween.slope < 0)) ||
         (oldSlope > 0 && ball.directionUpDown == 'bottom' && (quadrant == 1 || quadrant == 4) && lineBetween.slope < oldSlope)) 
      {
        newTrajectory.direction = 'right';
        newTrajectory.directionUpDown = 'bottom';
      }
      else {
        newTrajectory.direction = ball.direction;
        newTrajectory.directionUpDown = ball.directionUpDown;
      }
    }
    return newTrajectory;
  }

  function getSlopeReflectingAcrossSlope(oldSlope, slopeBetween) {
      // eq from StackOverflow: double M3 = ((2 * M1) + (M2 * pow(M1, 2)) - M2) / (2 * M1 * M2 - pow(M1, 2) + 1);
    return ((2 * slopeBetween) + (oldSlope * Math.pow(slopeBetween, 2)) - oldSlope) / ( 2 * slopeBetween * oldSlope - Math.pow(slopeBetween, 2) + 1);
  }

  function ballReflectingAgainstTable(ball) {
    var distanceMoving = ball.distanceMovedPerIncrement;
    if (ball.y > CORNER_MIN_Y && ball.y < CORNER_MAX_Y) {
      if (ball.x < TABLE_X + BALL_RADIUS_VALUE && ball.direction == 'left') {
        return 'horizontal';
      }
      else if (ball.x > TABLE_X + TABLE_WIDTH - BALL_RADIUS_VALUE && ball.direction == 'right') {
        return 'horizontal';
      }
    }
    if (ball.x > CORNER_MIN_X && ball.x < CORNER_MAX_X && !(ball.x > SIDE_MIN && ball.x < SIDE_MAX)) {
      if (ball.y < TABLE_Y + BALL_RADIUS_VALUE && ball.directionUpDown == 'bottom') {
        return 'vertical';
      }
      else if (ball.y > TABLE_Y + TABLE_HEIGHT - BALL_RADIUS_VALUE && ball.directionUpDown == 'top') {
        return 'vertical';
      }
    }
  }

  function calculateBallDataAfterReflection(ballReflecting, slope, direction, directionUpDown) {
    var result = {};
    result.slope = -1 * slope;
    if (ballReflecting == 'vertical') {
      if (directionUpDown == 'top') {
        result.direction = direction;
        result.directionUpDown = 'bottom';
      }
      else if (directionUpDown == 'bottom') {
        result.direction = direction;
        result.directionUpDown = 'top';
      }
    }
    else if (ballReflecting == 'horizontal') {
      if (direction == 'left') {
        result.directionUpDown = directionUpDown;
        result.direction = 'right';
      }
      else if (direction == 'right') {
        result.directionUpDown = directionUpDown;
        result.direction = 'left';
      }
    }
    return result;
  }

  function calculateNewLocation(ball) {
    var distanceTraveledX = Math.sqrt(ball.distanceMovedPerIncrement / (1 + Math.pow(ball.slope, 2)));
    var distanceTraveledY = Math.abs(ball.slope * distanceTraveledX);
    return {
      x: ball.x + distanceTraveledX * (ball.direction == 'left' ? -1 : 1),
      y: ball.y + distanceTraveledY * (ball.directionUpDown == 'bottom' ? -1 : 1),
    };
  }

  function lz(print, print2, print3, print4, print5, print6){
    console.log(print, print2, print3, print4, print5, print6);
  }

  function setTableSizeVariables() {
    var table = document.getElementById('table');
    var screen = document.getElementById('screen');
    if (table) {
      var tableInfo = table.getBoundingClientRect();
      var screenInfo = screen.getBoundingClientRect();
      TABLE_WIDTH = tableInfo.width;
      TABLE_HEIGHT = tableInfo.height;
      SCREEN_HEIGHT = screenInfo.height;
      SCREEN_X = screenInfo.x;
      SCREEN_Y = screenInfo.y;
      TABLE_X = tableInfo.x - SCREEN_X;
      TABLE_Y = tableInfo.y - SCREEN_Y;
      CORNER_MIN_X = TABLE_X + 25;
      CORNER_MAX_X = TABLE_WIDTH + TABLE_X - 24;
      CORNER_MIN_Y = TABLE_Y + 25;
      CORNER_MAX_Y = TABLE_HEIGHT + TABLE_Y - 23;
      SIDE_MIN = TABLE_X + 234;
      SIDE_MAX = TABLE_X + 280;
      BALL_RADIUS_VALUE = ACTUAL_BALL_RADIUS_PERCENTAGE * TABLE_WIDTH;
      setHoleLocations()
    }
  }

  function setHoleLocations() {
    var bottomLeftHole = document.getElementById('bottomlefthole').getBoundingClientRect();
    CORNER_HOLE_RADIUS = bottomLeftHole.width / 2;
    BOTTOM_LEFT_X = bottomLeftHole.left - SCREEN_X + CORNER_HOLE_RADIUS;
    BOTTOM_LEFT_Y = bottomLeftHole.top - SCREEN_Y + CORNER_HOLE_RADIUS;
    var bottomRightHole = document.getElementById('bottomrighthole').getBoundingClientRect();
    BOTTOM_RIGHT_X = bottomRightHole.left - SCREEN_X + CORNER_HOLE_RADIUS;
    BOTTOM_RIGHT_Y = bottomRightHole.top - SCREEN_Y + CORNER_HOLE_RADIUS;
    var topLeftHole = document.getElementById('toplefthole').getBoundingClientRect();
    TOP_LEFT_X = topLeftHole.left - SCREEN_X + CORNER_HOLE_RADIUS;
    TOP_LEFT_Y = topLeftHole.top - SCREEN_Y + CORNER_HOLE_RADIUS;
    var topRightHole = document.getElementById('toprighthole').getBoundingClientRect();
    TOP_RIGHT_X = topRightHole.left - SCREEN_X + CORNER_HOLE_RADIUS;
    TOP_RIGHT_Y = topRightHole.top - SCREEN_Y + CORNER_HOLE_RADIUS;
    var bottomSideHole = document.getElementById('bottomsidehole').getBoundingClientRect();
    SIDE_HOLE_RADIUS = bottomSideHole.width / 2;
    BOTTOM_SIDE_X = bottomSideHole.left - SCREEN_X + SIDE_HOLE_RADIUS;
    BOTTOM_SIDE_Y = bottomSideHole.top - SCREEN_Y + SIDE_HOLE_RADIUS;
    var topSideHole = document.getElementById('topsidehole').getBoundingClientRect();
    TOP_SIDE_X = topSideHole.left - SCREEN_X + SIDE_HOLE_RADIUS;
    TOP_SIDE_Y = topSideHole.top - SCREEN_Y + SIDE_HOLE_RADIUS;
  }

  function cursorOnTable(cursorX, cursorY) {
    if (cursorX < 0 || cursorY < 0) {
      return false;
    }
    else if (cursorX > TABLE_WIDTH || cursorY > TABLE_HEIGHT) {
      return false;
    }
    else {
      return true;
    }
  }

  function getPredictedCueLocationData(cursorX, cursorY, cueX, cueY) {
    var predictedLocationData = getPredictedLocation(cueX, cueY, adjustedPositionX(cursorX), adjustedPositionY(cursorY));
    return predictedLocationData;
  }

  function getElementTableLocationByID(id) {
    var element = document.getElementById(id);
    if (element) {
      var x = pixelLocationToNumericalValue(element.style.cx);
      var y = pixelLocationToNumericalValue(element.style.cy);
      return { x: x , y: y };
    }
  }

  function adjustedPositionX(x) {
    return x + TABLE_X;
  }

  function adjustedPositionY(y) {
    return y + TABLE_Y;
  }

  function getElementTableLocation(x, y) {
    var tableLocation = document.getElementById('table').getBoundingClientRect();
    var x = x - tableLocation.left;
    var y = y - tableLocation.top;
    return { x: x, y: y };
  }

  function getPredictedLocation(currentX, currentY, cursorX, cursorY) {
    var slope = (currentY - cursorY) / (currentX - cursorX);
    var yIntercept = currentY - (slope * currentX);
    var quadrant = getCursorQuadrant(currentX, currentY, cursorX, cursorY);
    var data;
    data = getLocationAgainstBall(slope, yIntercept, quadrant, currentX, currentY);
    if (!data) {
      data = getLocationAgainstTable(slope, yIntercept, quadrant);
    }
    return data;
  }

  function getLocationAgainstBall(slope, yIntercept, quadrant, currentX, currentY) {
    var balls = getBallsInCorrectQuadrant(quadrant, currentX, currentY);
    var unachievableDistance = TABLE_WIDTH;
    var currentClosestBall = { distanceBetweenCueAndBall: unachievableDistance };
    var distanceBetweenCenterOfTwoBalls = BALL_RADIUS_VALUE * 2;
    var foundIntersectingBall = null;
    for (var i = 0; i < balls.length; i++) {
      var ball = balls[i];
      var ballData = getBallDataInRelationToCue(ball, slope, yIntercept, currentX, currentY);
      if (ballData.distanceFromCueTrajectory < distanceBetweenCenterOfTwoBalls) {
        if (ballData.distanceBetweenCueAndBall < currentClosestBall.distanceBetweenCueAndBall) {
          currentClosestBall = ballData;
          foundIntersectingBall = ball;
        }
      }
    }
    if (foundIntersectingBall) {
      var distanceBetweenContactPointAndPerpendicularPoint = getSideFromHypotenuseAndSide(distanceBetweenCenterOfTwoBalls, currentClosestBall.distanceFromCueTrajectory);
      var distanceBetweenCueAndPerpendicularPoint = getHypotenuseFromDifferences(currentClosestBall.perpendicularPointX - currentX, currentClosestBall.perpendicularPointY - currentY);
      var ratioBetweenTwoDistanceTriangles = distanceBetweenContactPointAndPerpendicularPoint / distanceBetweenCueAndPerpendicularPoint;
      var xFromBallCenterToCueCenter = currentX - currentClosestBall.ballX;
      var yFromBallCenterToCueCenter = currentY - currentClosestBall.ballY;
      var xFromBallCenterToContactCenter = ratioBetweenTwoDistanceTriangles * xFromBallCenterToCueCenter;
      var yFromBallCenterToContactCenter = ratioBetweenTwoDistanceTriangles * yFromBallCenterToCueCenter;
      return {
        x: currentClosestBall.perpendicularPointX + xFromBallCenterToContactCenter,
        y: currentClosestBall.perpendicularPointY + yFromBallCenterToContactCenter,
        ball: foundIntersectingBall,
      };
    }
    else {
      return false;
    }
  }

  function getBallDataInRelationToCue(ball, slope, yIntercept, currentX, currentY) {
    var ballX = ball.x;
    var ballY = ball.y;
    var distanceBetweenCueAndBall = getHypotenuseFromDifferences(ballX - currentX, ballY - currentY);
    if (slope == Infinity) {
      var intersectionX = currentX;
      var intersectionY = ballY;
    }
    else if (slope == 0) {
      var intersectionX = ballX;
      var intersectionY = currentY;
    }
    else { //if, as usually the case, not a right-angle slope
      var perpendicularSlope = (1 / slope) * -1;
      var yInterceptOfPerpendicularLine = ballY - (perpendicularSlope * ballX);
      var intersectionX = (yIntercept - yInterceptOfPerpendicularLine) / (perpendicularSlope - slope);
      var intersectionY = intersectionX * slope + yIntercept;
    }
    var distanceFromCueTrajectory = getHypotenuseFromDifferences(ballX - intersectionX, ballY - intersectionY);
    return {
      distanceFromCueTrajectory: distanceFromCueTrajectory,
      perpendicularPointX: intersectionX, 
      perpendicularPointY: intersectionY,
      distanceBetweenCueAndBall: distanceBetweenCueAndBall,
      ballX: ballX,
      ballY: ballY,
    }
  }

  function getHypotenuseFromDifferences(x, y) {
    return Math.sqrt(Math.pow(Math.abs(x), 2) + Math.pow(Math.abs(y), 2));
  }

  function getSideFromHypotenuseAndSide(hypotenuse, side) {
    return Math.sqrt(Math.pow(Math.abs(hypotenuse), 2) - Math.pow(Math.abs(side), 2));
  }

  function getBallsInCorrectQuadrant(quadrant, currentX, currentY) {
    var balls = [];
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ball = ballsOnTable[i];
      if (ball.id != 'cueball' && ballInCorrectQuadrant(ball, quadrant, currentX, currentY)) {
        balls.push(ball);
      }
    }
    return balls;
  }

  function ballInCorrectQuadrant(ball, quadrant, currentX, currentY) {
    var ballX = ball.x;
    var ballY = ball.y;
    var allowance = BALL_RADIUS_VALUE * 2;
    if (quadrant == 1 && ballX > currentX - allowance && ballY > currentY - allowance) {
      return true;
    }
    else if (quadrant == 2 && ballX < currentX + allowance && ballY > currentY - allowance) {
      return true;
    }
    else if (quadrant == 3 && ballX < currentX + allowance && ballY < currentY + allowance) {
      return true;
    }
    else if (quadrant == 4 && ballX > currentX - allowance && ballY < currentY + allowance) {
      return true;
    }
    else if (quadrant == 1.5 && Math.abs(ballX - currentX) < allowance && ballY < currentY) {
      return true;
    }
    else if (quadrant == 2.5 && ballX < currentX && Math.abs(ballY - currentY) < allowance) {
      return true;
    }
    else if (quadrant == 3.5 && Math.abs(ballX - currentX) < allowance && ballY > currentY) {
      return true;
    }
    else if (quadrant == 4.5 && ballX > currentX && Math.abs(ballY - currentY) < allowance) {
      return true;
    }
    else {
      return false;
    }
  }

  function pixelLocationToNumericalValue(string) {
    string = string.slice(0, -2);
    return Number(string);
  }

  function getCursorQuadrant(currentX, currentY, cursorX, cursorY) {
    return getObjectQuadrant(currentX, currentY, cursorX, cursorY);
  }

  function getObjectQuadrant(baseX, baseY, X, Y) {
    // NOTE: output corresponds to quadrants of cartesian graph; half-values for when cursor on line
    if (X < baseX) {
      if (Y < baseY) {
        return 3;
      }
      else if (Y > baseY) {
        return 2;
      }
      else {
        return 2.5;
      }
    }
    else if (X > baseX) {
      if (Y > baseY) {
        return 1;
      }
      else if (Y < baseY) {
        return 4;
      }
      else {
        return 4.5;
      }
    }
    else {
      if (Y > baseY) {
        return 1.5;
      }
      else if (Y < baseY) {
        return 3.5;
      }
      else {
        return 4.5;
      }
    }
  }

  function getLocationAgainstTable(slope, yIntercept, quadrant) {
    // NOTE: Wall A is the far right wall; then the walls are named clockwise in alphabetical order
    var location;
    if (quadrant == 1) {
      location = getLocationAgainstWallA(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallB(slope, yIntercept, quadrant);
    }
    else if (quadrant == 2) {
      location = getLocationAgainstWallB(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallC(slope, yIntercept, quadrant);
    }
    else if (quadrant == 3) {
      location = getLocationAgainstWallC(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallD(slope, yIntercept, quadrant);
    }
    else if (quadrant == 4) {
      location = getLocationAgainstWallD(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallA(slope, yIntercept, quadrant);
    }
    else if (quadrant == 1.5) {
      location = getLocationAgainstWallB(slope, yIntercept, quadrant);
    }
    else if (quadrant == 2.5) {
      location = getLocationAgainstWallC(slope, yIntercept, quadrant);
    }
    else if (quadrant == 3.5) {
      location = getLocationAgainstWallD(slope, yIntercept, quadrant);
    }
    else if (quadrant == 4.5) {
      location = getLocationAgainstWallA(slope, yIntercept, quadrant);
    }
    return location;
  }

  function getLocationAgainstWallA(slope, yIntercept) {
    // NOTE: Wall A is the far right wall; then the walls are named clockwise in alphabetical order
    var xOfWall = TABLE_X + TABLE_WIDTH;
    var yMax = TABLE_Y + TABLE_HEIGHT;
    var yInterceptAgainstWall = xOfWall * slope + yIntercept;
    if (yInterceptAgainstWall > yMax) {
      return false;
    }
    else {
      var x = xOfWall - BALL_RADIUS_VALUE;
      return {
        x: x,
        y: getY(x, slope, yIntercept),
      };
    }
  }

  function getLocationAgainstWallB(slope, yIntercept) {
    var yOfWall = TABLE_Y + TABLE_HEIGHT;
    var xMin = 0 + TABLE_X;
    var xInterceptAgainstWall = (yOfWall - yIntercept) / slope;
    if (xInterceptAgainstWall < xMin) {
      return false;
    }
    else {
      var y = yOfWall - BALL_RADIUS_VALUE;
      return {
        x: getX(y, slope, yIntercept),
        y: y,
      };
    }
  }

  function getLocationAgainstWallC(slope, yIntercept) {
    var xOfWall = 0 + TABLE_X;
    var yMin = 0 + TABLE_Y;
    var yInterceptAgainstWall = xOfWall * slope + yIntercept;
    if (yInterceptAgainstWall < yMin) {
      return false;
    }
    else {
      var x = xOfWall + BALL_RADIUS_VALUE;
      return {
        x: x,
        y: getY(x, slope, yIntercept),
      };
    }
  }

  function getLocationAgainstWallD(slope, yIntercept) {
    var yOfWall = 0 + TABLE_Y;
    var xMax = TABLE_WIDTH + TABLE_X;
    var xInterceptAgainstWall = (yOfWall - yIntercept) / slope;
    if (xInterceptAgainstWall > xMax) {
      return false;
    }
    else {
      var y = yOfWall + BALL_RADIUS_VALUE;
      return {
        x: getX(y, slope, yIntercept),
        y: y,
      };
    }
  }

  function getX(y, slope, yIntercept) {
    return (y - yIntercept) / slope;
  }

  function getY(x, slope, yIntercept) {
    return x * slope + yIntercept;
  }

  function placeRandomBall(color, multiple) {
    var randomX = adjustedPositionX(Math.random() * (TABLE_WIDTH - BALL_RADIUS_VALUE * 2) + BALL_RADIUS_VALUE) + 'px';
    var randomY = adjustedPositionY(Math.random() * (TABLE_HEIGHT - BALL_RADIUS_VALUE * 2) + BALL_RADIUS_VALUE) + 'px';
    if (!multiple) {
      return placeBall(color || 'red', randomX, randomY, 'cueball');
    }
    else {
      return placeBall(color || 'red', randomX, randomY);
    }
  }

  function placeNonrandomBalls() {
    var result = [];
    result.push(placeBall('grey', 82 + 'px', 49 + 'px', 'cueball'));
    result.push(placeBall('green', 167 + 'px', 43 + 'px'));
    result.push(placeBall('green', 354 + 'px', 78 + 'px'));
    return result;
  }

  function placeRandomBalls() {
    var balls = [];
    for (var i = 0; i < TEST_BALL_NUM; i++) {
      var ball = placeRandomBall('green', true);
      balls.push(ball);
    }
    return balls;
  }

  function placeBall(color, cx, cy, id) {
    var ball;
    appendSVG('circle', function(element) {
      ball = element;
      element.style.fill = color || 'red';
      element.style.r = BALL_RADIUS;
      element.style.cx = cx;
      element.style.cy = cy;
      element.x = pixelLocationToNumericalValue(cx);
      element.y = pixelLocationToNumericalValue(cy);
      if (id) element.id = id;
    });
    return ball;
  }

  function placePredictorBall(cx, cy) {
    var ball = document.getElementById('predictorball');
    if (!ball) {
      appendSVG('circle', function(element) {
        ball = element;
        element.id = 'predictorball';
        element.style.fill = 'transparent';
        element.style.stroke = 'white'
        element.style.strokeWidth = '2px'
        element.style.r = BALL_RADIUS;
      });
    }
    ball.style.cx = cx;
    ball.style.cy = cy;
    ball.x = pixelLocationToNumericalValue(cx);
    ball.y = pixelLocationToNumericalValue(cy);
    return ball;
  }

  function appendSVG(type, setAttributeAndStyle) {
    var svg = document.getElementsByTagName('svg')[0];
    var newElement = document.createElementNS("http://www.w3.org/2000/svg", type);
    if (setAttributeAndStyle) setAttributeAndStyle(newElement);
    svg.appendChild(newElement);
  }

</script>
<style>

  #container {
    height: 400px;
    width: 800px;
    display: block;
    margin: auto;
    margin-top: 50px;
  }
  
  svg {
    width: 100%;
    height: 100%;
    display: block;
    margin: auto;
    margin-top: 50px;
  }

  #screen {
    width: 100%;
    height: 100%;
  }

  #table {
    fill: darkblue;
    width: 62.5%;
    height: 62.5%;
    x: 20%;
    y: 20%;
  }

  #guardrails {
    fill: brown;
    width: 73%; 
    height: 82%; 
    x: 14.7%;
    y: 10.1%;
    z-index: -1;
  }

  .cornerhole {
    fill: black;
    r: 3%;
  }

  #toplefthole {
    cx: 18.5%;
    cy: 85.5%;
  }

  #bottomlefthole {
    cx: 18.5%;
    cy: 17%;
  }

  #bottomrighthole {
    cx: 84%;
    cy: 17%;
  }

  #toprighthole {
    cx: 84%;
    cy: 85.5%;
  }

  .cornerlane {
    fill: darkblue;
    transform-box: fill-box;
    transform-origin: center;
  }

  #topleftlane {
    x: 17.7%;
    y: 78%;
    width: 5%;
    height: 8.5%;
  }

  #bottomleftlane {
    x: 18%;
    y: 16.7%;
    width: 5%;
    height: 8.5%;
  }

  #bottomrightlane {
    x: 80%;
    y: 15.7%;
    width: 5%;
    height: 8.5%;
  }

  #toprightlane {
    x: 79.9%;
    y: 78%;
    width: 5%;
    height: 8.5%;
  }

  .sidehole {
    fill: black;
    r: 2.5%;
  }

  #bottomsidehole {
    cx: 52%;
    cy: 16%;
  }

  #topsidehole {
    cx: 52%;
    cy: 86.5%;
  }

  .sidelane {
    fill: darkblue;
    transform-box: fill-box;
    transform-origin: center;
  }

  #bottomleftsidelane {
    x: 50.7%;
    y: 16%;
    width: 5%;
    height: 5%;
  }

  #bottomrightsidelane {
    x: 48.4%;
    y: 16%;
    width: 5%;
    height: 5%;
  }

  #toprightsidelane {
    x: 49.3%;
    y: 79.5%;
    width: 5%;
    height: 5%;
  }

  #topleftsidelane {
    x: 49.7%;
    y: 79.5%;
    width: 5%;
    height: 5%;
  }

  #powerselector {
    fill: grey;
    width: 5%;
    height: 50%;
    x: 5%;
    y: 30%;
  }

  #powerselectorcover {
    fill: black;
    opacity: 0;
    width: 5%;
    height: 50%;
    x: 0%;
    y: 30%;
  }

  #powerdisplay {
    fill: black;
    width: 3%;
    height: 48%;
    x: 6%;
    y: 31%;
  }

  #stick {
    fill: yellow;
    width: 1%;
    height: 47%;
    x: 7%;
    y: 32%;
  }

  #block {
    fill: black;
    width: 5%;
    height: 20%;
    x: 5%;
    y: 80%;
  }

  #powerselectorbottom {
    fill: grey;
    width: 5%;
    height: 2%;
    x: 5%;
    y: 79%;
  }

</style>
</html>
