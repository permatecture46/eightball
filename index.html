<html>
<head>
</head>
<body>
  <div id="container">
    <svg xmlns="http://www.w3.org/2000/svg">
      <rect id="screen"/>
      <rect id="table"/>
    </svg>
  </div>
</body>
<script>

  var BALL_RADIUS_PERCENTAGE = .0205; // this value makes it so it becomes the actual American standard of ~.026
  var ACTUAL_BALL_RADIUS_PERCENTAGE = BALL_RADIUS_PERCENTAGE + .265 * BALL_RADIUS_PERCENTAGE; // for some reason this is how it renders...
  var BALL_RADIUS = BALL_RADIUS_PERCENTAGE * 100 + "%";
  var TABLE_WIDTH, TABLE_HEIGHT, BALL_RADIUS_VALUE;
  var TIME_BETWEEN_INCREMENTS = 5;
  var MAX_DISTANCE_MOVED = 1;
  var TEST_BALL_NUM = 1;

  var ballsOnTable = [];

  window.addEventListener('load', function(event) {
    setTableSizeVariables();
    ballsOnTable = placeRandomBalls();
    ballsOnTable.push(placeRandomBall());
    setPredictedCueLocationListener();
    setClickListener();
  });

  function setPredictedCueLocationListener() {
    document.addEventListener('mousemove', function(event) {
      var location = getElementTableLocation(event.clientX, event.clientY);
      if (cursorOnTable(location.x, location.y)) {
        clearPreviousPredictedLocation();
        placePredictedCueLocation(location.x, location.y);
      }
    });
  }

  function setClickListener() {
    document.addEventListener('click', function(event) {
      var cursorLocationOnTable = getElementTableLocation(event.clientX, event.clientY);
      setInitialCueBallMovementData(cursorLocationOnTable.x, cursorLocationOnTable.y);
      incrementLocationsOfBalls();
    });
  }
  
  function setInitialCueBallMovementData(cursorX, cursorY) {
    var cueBall = document.getElementById('cue');
    cueBall.x = pixelLocationToNumericalValue(cueBall.style.cx);
    cueBall.y = pixelLocationToNumericalValue(cueBall.style.cy);
    cueBall.slope = (cursorY - cueBall.y) / (cursorX - cueBall.x);
    cueBall.direction = cursorX < cueBall.x ? 'left' : 'right';
    cueBall.directionUpDown = cursorY > cueBall.y ? 'top' : 'bottom';
    cueBall.distanceMovedPerIncrement = MAX_DISTANCE_MOVED;
    cueBall.isMoving = true;
  }

  function incrementLocationsOfBalls(ballJustStruck) {
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ball = ballsOnTable[i];
      if (ball.isMoving) {
        var newLocation = calculateNewLocation(ball);
        ball.style.cx = newLocation.x + 'px';
        ball.style.cy = newLocation.y + 'px';
        ball.x = newLocation.x;
        ball.y = newLocation.y;
// put slow down code here
        var ballStruck = ballStrikingOtherBall(ball);
        if (!!ballStruck && !ballJustStruck) {
          var newBallData = calculateBallDataAfterStriking(ball, ballStruck);
          ball.slope = newBallData.slope;
          ball.direction = newBallData.direction;
          ball.directionUpDown = newBallData.directionUpDown;
          ballJustStruck = true;
// fill me in
        }
        else {
          var ballReflecting = ballReflectingAgainstTable(ball);
          if (!!ballReflecting) { // implicit else if
            var newBallData = calculateBallDataAfterReflection(ballReflecting, ball.slope, ball.direction, ball.directionUpDown);
            ball.slope = newBallData.slope;
            ball.direction = newBallData.direction;
            ball.directionUpDown = newBallData.directionUpDown;
            // ball.distance change this later!
          }
        }
      }
    }
    setTimeout(function() {
      incrementLocationsOfBalls(ballJustStruck);
    }, TIME_BETWEEN_INCREMENTS);
  }

  function ballStrikingOtherBall(ball) {
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ballToCheck = ballsOnTable[i];
      if (ball != ballToCheck) {
        var distanceBetweenBalls = getHypotenuseFromDifferences(ball.x - ballToCheck.x, ball.y - ballToCheck.y);
        if (distanceBetweenBalls < 2 * BALL_RADIUS_VALUE) {
          return ballToCheck;
        }
      }
    }
  }

  function calculateBallDataAfterStriking(ball, ballStruck) {
    var lineBetween = {};
    lineBetween.slope = (ball.y - ballStruck.y) / (ball.x - ballStruck.x);
    lineBetween.yIntercept = ball.y - lineBetween.slope * ball.x;
    var newTrajectory = {};
       // eq from StackOverflow: double M3 = ((2 * M1) + (M2 * pow(M1, 2)) - M2) / (2 * M1 * M2 - pow(M1, 2) + 1);
    var newSlope = ((2 * lineBetween.slope) + (ball.slope * Math.pow(lineBetween.slope, 2)) - ball.slope) / ( 2 * lineBetween.slope * ball.slope - Math.pow(lineBetween.slope, 2) + 1);
    newTrajectory.slope = newSlope;
    var oldSlope = ball.slope;
    var quadrant = getObjectQuadrant(ballStruck.x, ballStruck.y, ball.x, ball.y);
    if (newSlope > 0) {
      if ((oldSlope > 0 && ball.direction == 'right' && quadrant == 1) || 
         (oldSlope < 0 && ball.direction == 'right' && (quadrant == 2 || quadrant == 1)) ||
         (oldSlope < 0 && ball.directionUpDown == 'top' && (quadrant == 4 || quadrant == 1))) 
      {
        newTrajectory.direction = 'right';
        newTrajectory.directionUpDown = 'top';
      }
      else if ((oldSlope < 0 && ball.direction == 'left' && quadrant == 3) || 
         (oldSlope > 0 && ball.direction == 'left' && (quadrant == 3 || quadrant == 4)) ||
         (oldSlope > 0 && ball.directionUpDown == 'bottom' && (quadrant == 3 || quadrant == 2)))
      {
        newTrajectory.direction = 'left';
        newTrajectory.directionUpDown = 'bottom';
      }
    }
    else if (newSlope < 0) {
      if ((oldSlope < 0 && ball.direction == 'left' && quadrant == 2) || 
         (oldSlope > 0 && ball.direction == 'left' && (quadrant == 2 || quadrant == 1) && (lineBetween.slope > 1)) ||
         (oldSlope > 0 && ball.directionUpDown == 'top' && (quadrant == 2 || quadrant == 3))) 
      {
        newTrajectory.direction = 'left';
        newTrajectory.directionUpDown = 'top';
      }
      else if ((oldSlope > 0 && ball.direction == 'right' && quadrant == 4) || 
         (oldSlope < 0 && ball.direction == 'right' && (quadrant == 3 || quadrant == 4)) ||
         (oldSlope < 0 && ball.directionUpDown == 'bottom' && (quadrant == 1 || quadrant == 4))) 
      {
        newTrajectory.direction = 'right';
        newTrajectory.directionUpDown = 'bottom';
      }
    }
    return newTrajectory;
  }

  function ballReflectingAgainstTable(ball) {
    var distanceMoving = ball.distanceMovedPerIncrement;
    if (ball.x < BALL_RADIUS_VALUE && ball.direction == 'left') {
      return 'horizontal';
    }
    else if (ball.x > (TABLE_WIDTH - (BALL_RADIUS_VALUE)) && ball.direction == 'right') {
      return 'horizontal';
    }
    else if (ball.y < BALL_RADIUS_VALUE && ball.directionUpDown == 'bottom') {
      return 'vertical';
    }
    else if (ball.y > (TABLE_HEIGHT - (BALL_RADIUS_VALUE)) && ball.directionUpDown == 'top') {
      return 'vertical';
    }
  }

  function calculateBallDataAfterReflection(ballReflecting, slope, direction, directionUpDown) {
    var result = {};
    result.slope = -1 * slope;
    if (ballReflecting == 'vertical') {
      if (directionUpDown == 'top') {
        result.direction = direction;
        result.directionUpDown = 'bottom';
      }
      else if (directionUpDown == 'bottom') {
        result.direction = direction;
        result.directionUpDown = 'top';
      }
    }
    else if (ballReflecting == 'horizontal') {
      if (direction == 'left') {
        result.directionUpDown = directionUpDown;
        result.direction = 'right';
      }
      else if (direction == 'right') {
        result.directionUpDown = directionUpDown;
        result.direction = 'left';
      }
    }
    return result;
  }

  function calculateNewLocation(ball) {
    var distanceTraveledX = Math.sqrt(ball.distanceMovedPerIncrement / (1 + Math.pow(ball.slope, 2)));
    var distanceTraveledY = Math.abs(ball.slope * distanceTraveledX);
    return {
      x: ball.x + distanceTraveledX * (ball.direction == 'left' ? -1 : 1),
      y: ball.y + distanceTraveledY * (ball.directionUpDown == 'bottom' ? -1 : 1),
    };
  }

  function lz(print, print2, print3, print4, print5){
    console.log(print, print2, print3, print4, print5);
  }

  function clearPreviousPredictedLocation() {
    var predictedBall = document.getElementById('predicted');
    if (predictedBall) {
      predictedBall.parentNode.removeChild(predictedBall);
    }
  }

  function setTableSizeVariables() {
    var table = document.getElementById('table');
    if (table) {
      var tableInfo = table.getBoundingClientRect();
      TABLE_WIDTH = tableInfo.width;
      TABLE_HEIGHT = tableInfo.height;
      BALL_RADIUS_VALUE = ACTUAL_BALL_RADIUS_PERCENTAGE * TABLE_WIDTH;
    }
  }

  function cursorOnTable(cursorX, cursorY) {
    if (cursorX < 0 || cursorY < 0) {
      return false;
    }
    else if (cursorX > TABLE_WIDTH || cursorY > TABLE_HEIGHT) {
      return false;
    }
    else {
      return true;
    }
  }

  function placePredictedCueLocation(cursorX, cursorY) {
    var currentLocation = getElementTableLocationByID('cue');
    var predictedLocation = getPredictedLocation(currentLocation.x, currentLocation.y, cursorX, cursorY);
    placeBall('white', predictedLocation.x + 'px', predictedLocation.y + 'px', 'predicted');
  }

  function getElementTableLocationByID(id) {
    var element = document.getElementById(id);
    var x = pixelLocationToNumericalValue(element.style.cx);
    var y = pixelLocationToNumericalValue(element.style.cy);
    return { x: x , y: y };
  }

  function getElementTableLocation(x, y) {
    var tableLocation = document.getElementById('table').getBoundingClientRect();
    var x = x - tableLocation.left;
    var y = y - tableLocation.top;
    return { x: x, y: y };
  }

  function getPredictedLocation(currentX, currentY, cursorX, cursorY) {
    var slope = (currentY - cursorY) / (currentX - cursorX);
    var yIntercept = currentY - (slope * currentX);
    var quadrant = getCursorQuadrant(currentX, currentY, cursorX, cursorY);
    var location;
    location = getLocationAgainstBall(slope, yIntercept, quadrant, currentX, currentY);
    if (!location) {
      location = getLocationAgainstTable(slope, yIntercept, quadrant);
    }
    return location;
  }

  function getLocationAgainstBall(slope, yIntercept, quadrant, currentX, currentY) {
    var balls = getBallsInCorrectQuadrant(quadrant, currentX, currentY);
    var unachievableDistance = TABLE_WIDTH;
    var currentClosestBall = { distanceBetweenCueAndBall: unachievableDistance };
    var distanceBetweenCenterOfTwoBalls = BALL_RADIUS_VALUE * 2;
    var foundIntersectingBall = null;
    for (var i = 0; i < balls.length; i++) {
      var ball = balls[i];
      var ballData = getBallData(ball, slope, yIntercept, currentX, currentY);
      if (ballData.distanceFromCueTrajectory < distanceBetweenCenterOfTwoBalls) {
        if (ballData.distanceBetweenCueAndBall < currentClosestBall.distanceBetweenCueAndBall) {
          currentClosestBall = ballData;
          foundIntersectingBall = true;
        }
      }
    }
    if (foundIntersectingBall) {
      var distanceBetweenContactPointAndPerpendicularPoint = getSideFromHypotenuseAndSide(distanceBetweenCenterOfTwoBalls, ballData.distanceFromCueTrajectory);
      var distanceBetweenCueAndPerpendicularPoint = getHypotenuseFromDifferences(ballData.perpendicularPointX - currentX, ballData.perpendicularPointY - currentY);
      var ratioBetweenTwoDistanceTriangles = distanceBetweenContactPointAndPerpendicularPoint / distanceBetweenCueAndPerpendicularPoint;
      var xFromBallCenterToCueCenter = currentX - ballData.ballX;
      var yFromBallCenterToCueCenter = currentY - ballData.ballY;
      var xFromBallCenterToContactCenter = ratioBetweenTwoDistanceTriangles * xFromBallCenterToCueCenter;
      var yFromBallCenterToContactCenter = ratioBetweenTwoDistanceTriangles * yFromBallCenterToCueCenter;
      return {
        x: ballData.perpendicularPointX + xFromBallCenterToContactCenter,
        y: ballData.perpendicularPointY + yFromBallCenterToContactCenter,
      };
    }
    else {
      return false;
    }
  }

  function getBallData(ball, slope, yIntercept, currentX, currentY) {
    var ballX = pixelLocationToNumericalValue(ball.style.cx);
    var ballY = pixelLocationToNumericalValue(ball.style.cy);
    var perpendicularSlope = (1 / slope) * -1;
    var yInterceptOfPerpendicularLine = ballY - (perpendicularSlope * ballX);
    var intersectionX = (yIntercept - yInterceptOfPerpendicularLine) / (perpendicularSlope - slope);
    var intersectionY = intersectionX * slope + yIntercept;
    var distanceFromCueTrajectory = getHypotenuseFromDifferences(ballX - intersectionX, ballY - intersectionY);
    var distanceBetweenCueAndBall = getHypotenuseFromDifferences(ballX - currentX, ballY - currentY);
    return {
      distanceFromCueTrajectory: distanceFromCueTrajectory,
      perpendicularPointX: intersectionX, 
      perpendicularPointY: intersectionY,
      distanceBetweenCueAndBall: distanceBetweenCueAndBall,
      ballX: ballX,
      ballY: ballY,
    }
  }

  function getHypotenuseFromDifferences(x, y) {
    return Math.sqrt(Math.pow(Math.abs(x), 2) + Math.pow(Math.abs(y), 2));
  }

  function getSideFromHypotenuseAndSide(hypotenuse, side) {
    return Math.sqrt(Math.pow(Math.abs(hypotenuse), 2) - Math.pow(Math.abs(side), 2));
  }

  function getBallsInCorrectQuadrant(quadrant, currentX, currentY) {
    var balls = [];
    for (var i = 0; i < ballsOnTable.length; i++) {
      var ball = ballsOnTable[i];
      if (ball.id != "cue" && ballInCorrectQuadrant(ball, quadrant, currentX, currentY)) {
        balls.push(ball);
      }
    }
    return balls;
  }

  function ballInCorrectQuadrant(ball, quadrant, currentX, currentY) {
    var ballX = pixelLocationToNumericalValue(ball.style.cx);
    var ballY = pixelLocationToNumericalValue(ball.style.cy);
    if (quadrant == 1 && ballX > currentX && ballY > currentY) {
      return true;
    }
    else if (quadrant == 2 && ballX < currentX && ballY > currentY) {
      return true;
    }
    else if (quadrant == 3 && ballX < currentX && ballY < currentY) {
      return true;
    }
    else if (quadrant == 4 && ballX > currentX && ballY < currentY) {
      return true;
    }
    else if (quadrant == 1.5 && ballX == currentX && ballY < currentY) {
      return true;
    }
    else if (quadrant == 2.5 && ballX < currentX && ballY == currentY) {
      return true;
    }
    else if (quadrant == 3.5 && ballX == currentX && ballY > currentY) {
      return true;
    }
    else if (quadrant == 4.5 && ballX > currentX && ballY == currentY) {
      return true;
    }
    else {
      return false;
    }
  }

  function pixelLocationToNumericalValue(string) {
    string = string.slice(0, -3);
    return Number(string);
  }

  function getCursorQuadrant(currentX, currentY, cursorX, cursorY) {
    return getObjectQuadrant(currentX, currentY, cursorX, cursorY);
  }

  function getObjectQuadrant(baseX, baseY, X, Y) {
    // NOTE: output corresponds to quadrants of cartesian graph; half-values for when cursor on line
    if (X < baseX) {
      if (Y < baseY) {
        return 3;
      }
      else if (Y > baseY) {
        return 2;
      }
      else {
        return 2.5;
      }
    }
    else if (X > baseX) {
      if (Y > baseY) {
        return 1;
      }
      else if (Y < baseY) {
        return 4;
      }
      else {
        return 4.5;
      }
    }
    else {
      if (Y > baseY) {
        return 1.5;
      }
      else if (Y < baseY) {
        return 3.5;
      }
      else {
        return 4.5;
      }
    }
  }

  function getLocationAgainstTable(slope, yIntercept, quadrant) {
    // NOTE: Wall A is the far right wall; then the walls are named clockwise in alphabetical order
    var location;
    if (quadrant == 1) {
      location = getLocationAgainstWallA(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallB(slope, yIntercept, quadrant);
    }
    else if (quadrant == 2) {
      location = getLocationAgainstWallB(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallC(slope, yIntercept, quadrant);
    }
    else if (quadrant == 3) {
      location = getLocationAgainstWallC(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallD(slope, yIntercept, quadrant);
    }
    else if (quadrant == 4) {
      location = getLocationAgainstWallD(slope, yIntercept, quadrant);
      if (!location) location = getLocationAgainstWallA(slope, yIntercept, quadrant);
    }
    else if (quadrant == 1.5) {
      location = getLocationAgainstWallB(slope, yIntercept, quadrant);
    }
    else if (quadrant == 2.5) {
      location = getLocationAgainstWallC(slope, yIntercept, quadrant);
    }
    else if (quadrant == 3.5) {
      location = getLocationAgainstWallD(slope, yIntercept, quadrant);
    }
    else if (quadrant == 4.5) {
      location = getLocationAgainstWallA(slope, yIntercept, quadrant);
    }
    return location;
  }

  function getLocationAgainstWallA(slope, yIntercept) {
    // NOTE: Wall A is the far right wall; then the walls are named clockwise in alphabetical order
    var xOfWall = TABLE_WIDTH;
    var yMax = TABLE_HEIGHT;
    var yInterceptAgainstWall = xOfWall * slope + yIntercept;
    if (yInterceptAgainstWall > yMax) {
      return false;
    }
    else {
      var x = xOfWall - BALL_RADIUS_VALUE;
      return {
        x: x,
        y: getY(x, slope, yIntercept),
      };
    }
  }

  function getLocationAgainstWallB(slope, yIntercept) {
    var yOfWall = TABLE_HEIGHT;
    var xMin = 0;
    var xInterceptAgainstWall = (yOfWall - yIntercept) / slope;
    if (xInterceptAgainstWall < xMin) {
      return false;
    }
    else {
      var y = yOfWall - BALL_RADIUS_VALUE;
      return {
        x: getX(y, slope, yIntercept),
        y: y,
      };
    }
  }

  function getLocationAgainstWallC(slope, yIntercept) {
    var xOfWall = 0;
    var yMin = 0;
    var yInterceptAgainstWall = xOfWall * slope + yIntercept;
    if (yInterceptAgainstWall < yMin) {
      return false;
    }
    else {
      var x = xOfWall + BALL_RADIUS_VALUE;
      return {
        x: x,
        y: getY(x, slope, yIntercept),
      };
    }
  }

  function getLocationAgainstWallD(slope, yIntercept) {
    var yOfWall = 0;
    var xMax = TABLE_WIDTH;
    var xInterceptAgainstWall = (yOfWall - yIntercept) / slope;
    if (xInterceptAgainstWall > xMax) {
      return false;
    }
    else {
      var y = yOfWall + BALL_RADIUS_VALUE;
      return {
        x: getX(y, slope, yIntercept),
        y: y,
      };
    }
  }

  function getX(y, slope, yIntercept) {
    return (y - yIntercept) / slope;
  }

  function getY(x, slope, yIntercept) {
    return x * slope + yIntercept;
  }

  function placeRandomBall(color, multiple) {
    var randomX = Math.random() * (TABLE_WIDTH - BALL_RADIUS_VALUE * 2) + BALL_RADIUS_VALUE + 'px';
    var randomY = Math.random() * (TABLE_HEIGHT - BALL_RADIUS_VALUE * 2) + BALL_RADIUS_VALUE + 'px';
    if (!multiple) {
      return placeBall(color || 'red', randomX, randomY, 'cue');
    }
    else {
      return placeBall(color || 'red', randomX, randomY);
    }
  }

  function placeRandomBalls() {
    var balls = [];
    for (var i = 0; i < TEST_BALL_NUM; i++) {
      var ball = placeRandomBall('green', true);
      balls.push(ball);
    }
    return balls;
  }

  function placeBall(color, cx, cy, id) {
    var ball;
    appendSVG('circle', function(element) {
      ball = element;
      element.style.fill = color || 'red';
      element.style.r = BALL_RADIUS;
      element.style.cx = cx;
      element.style.cy = cy;
      element.x = pixelLocationToNumericalValue(cx);
      element.y = pixelLocationToNumericalValue(cy);
      if (id) element.id = id;
    });
    return ball;
  }

  function appendSVG(type, setAttributeAndStyle) {
    var svg = document.getElementsByTagName('svg')[0];
    var newElement = document.createElementNS("http://www.w3.org/2000/svg", type);
    if (setAttributeAndStyle) setAttributeAndStyle(newElement);
    svg.appendChild(newElement);
  }

</script>
<style>

  #container {
    height: 400px;
    width: 800px;
    display: block;
    margin: auto;
    margin-top: 50px;
  }
  
  svg {
    width: 100%;
    height: 100%;
    display: block;
    margin: auto;
    margin-top: 50px;
  }

  #screen {
    width: 100%;
    height: 100%;
  }

  #table {
    fill: blue;
    width: 62.5%;
    height: 62.5%;
  }

</style>
</html>
